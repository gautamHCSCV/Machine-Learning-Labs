# -*- coding: utf-8 -*-
"""B19EE031 Lab_7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wIPwqVLqhWy_6vy7ZwXDA8lS-ya8u05w
"""

import pandas  as pd 
import numpy as np 
import matplotlib.pyplot as plt 
import seaborn as sns 
from sklearn import datasets

"""Loading the dataset"""

iris = datasets.load_iris()
iris.data

y = iris.target
y

iris.DESCR

"""Considering the first 2 features"""

x = iris['data'][:,:2]
X = pd.DataFrame(x)
X.head()

plt.scatter(X.iloc[:,0],X.iloc[:,1])
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.plot()

"""Building the model"""

#For random initialization of centroids
np.random.seed(42)
centroid = (X.sample(n=3))
centroid

#Euclidiean distance
def euclidean_distance(x1,x2):
  return(np.sqrt(np.sum((x1-x2)**2,axis = 1)))

class KMeansCluster:
  def __init__(self, X, num_clusters):
    self.k = num_clusters
    self.max_iterations = 100
    self.num_examples = X.shape[0]
    self.num_columns = X.shape[1]

  def initialize_centroids(self, X):  # Initializing random centroids
    centroids = np.zeros((self.k, self.num_columns))
    for k in range(self.k):
      centroid = X[np.random.choice(range(self.num_examples))]
      centroids[k] = centroid
    return(centroids)

  def create_clusters(self, X, centroids):
    # Cordinates of each cluster
    clusters = [[] for _ in range(self.k)]

    # Cluster reassigning
    for point_index, point in enumerate(X):
      new_centroid = np.argmin(euclidean_distance(point, centroid))
      clusters[new_centroid].append(point_index)
    return(clusters)

  def calculate_new_centroids(self, clusters, X):  # reassigning of centroid of updated cluster
    centroids = np.zeros((self.k, self.num_columns))
    for index, cluster in enumerate(clusters):
      new_centroid = np.mean(X[cluster], axis=0)
      centroids[index] = new_centroid
    return(centroids)

  def predict_cluster(self, clusters, X):
    y_pred = np.zeros(self.num_examples)

    for cluster_index, cluster in enumerate(clusters):
      for sample_index in cluster:
        y_pred[sample_index] = cluster_index
    return(y_pred)

  def fit(self, X):
    centroids = self.initialize_centroids(X)
    for it in range(self.max_iterations):
      clusters = self.create_clusters(X, centroids)
      previous_centroids = centroids
      centroids = self.calculate_new_centroids(clusters, X)
      diff = centroids - previous_centroids

      if not diff.any(): # if there is no change in coordinates of centroids, we break the loop 
        print("Terminating after {}th iteration as there is no futher change in centroids.".format(it+1))
        break
    y_pred = self.predict_cluster(clusters, X)
    return(y_pred, centroids)

"""Using the model for clustering among first 2 features of iris dataset."""

k = 3
x = np.array(x)
model = KMeansCluster(x, k)
y_pred,centroids = model.fit(x)
y_pred

centroids

plt.scatter(x[:, 0], x[:, 1], c=y_pred)
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.show()

X['predictions'] = y_pred
df0 = X[X['predictions']==0]
df1 = X[X['predictions']==1]
df2 = X[X['predictions']==2]

plt.scatter(df0.iloc[:,0],df0.iloc[:,1],color = 'yellow',label = 'Setosa')
plt.scatter(df1.iloc[:,0],df1.iloc[:,1],color = 'green', label = 'Versicolour')
plt.scatter(df2.iloc[:,0],df2.iloc[:,1],color = 'blue', label = 'Virginica')
plt.scatter(centroids[:,0],centroids[:,1],label = 'centroids',marker = '*',color = 'black',linewidths=3)
plt.xlabel('feature 1')
plt.ylabel('feature 2')
plt.legend()
plt.show()

"""Using the same model for feature 2 and 3"""

x = iris.data[:,1:3]
x = np.array(x)
plt.scatter(x[:,0],x[:,1])
plt.xlabel('Feature 2')
plt.ylabel('Feature 3')
plt.show()

model = KMeansCluster(x, 3)
y_pred,centroids = model.fit(x)
y_pred

plt.scatter(x[:, 0], x[:, 1], c=y_pred)
plt.scatter(centroids[:,0],centroids[:,1],label = 'centroids',marker = '*',color = 'black',linewidths=3)
plt.xlabel('feature 2')
plt.ylabel('feature 3')
plt.legend()
plt.show()
plt.show()

"""Model using KMeans"""

from sklearn.cluster import KMeans
km = KMeans(n_clusters = 3)

x = iris['data'][:,:2]
X = pd.DataFrame(x)
y_pred = km.fit_predict(x)
print(y_pred)

km.cluster_centers_

X['predictions'] = y_pred
X.head()

df0 = X[X['predictions']==0]
df1 = X[X['predictions']==1]
df2 = X[X['predictions']==2]

plt.scatter(df0.iloc[:,0],df0.iloc[:,1],color = 'yellow')
plt.scatter(df1.iloc[:,0],df1.iloc[:,1],color = 'green')
plt.scatter(df2.iloc[:,0],df2.iloc[:,1],color = 'blue')
plt.show()

"""Plot with centroids"""

plt.scatter(df0.iloc[:,0],df0.iloc[:,1],color = 'yellow',label = 'Setosa')
plt.scatter(df1.iloc[:,0],df1.iloc[:,1],color = 'green', label = 'Versicolour')
plt.scatter(df2.iloc[:,0],df2.iloc[:,1],color = 'blue', label = 'Virginica')
plt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],label = 'centroids',marker = '*',color = 'black',linewidths=3)
plt.xlabel('feature 1')
plt.ylabel('feature 2')
plt.legend()
plt.show()

# Calculating sum of squared error of the distances
km.inertia_

#plotting decision boundaries
kmeans = KMeans(n_clusters=3)
h = .02     # point in the mesh [x_min, x_max]x[y_min, y_max].
X = iris.data
Y = iris.target
kmeans.fit(X[:,:2],Y)
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))

Z = kmeans.predict(np.c_[xx.ravel(), yy.ravel()])

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(1)
plt.clf()
plt.imshow(Z, interpolation='nearest',
       extent=(xx.min(), xx.max(), yy.min(), yy.max()),
       cmap=plt.cm.Paired,
       aspect='auto', origin='lower')

plt.plot(X[:, 0], X[:, 1], 'k.', markersize=5)
# Plot the centroids as a white X
centroids = kmeans.cluster_centers_
plt.scatter(centroids[:, 0], centroids[:, 1],
        marker='x', s=169, linewidths=3,
        color='w', zorder=10)
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.xticks(())
plt.yticks(())
plt.show()

"""Choosing appropriate value for k"""

sse = [] #stores sum of square error
for k in range(1,8):
  km = KMeans(n_clusters=k)
  km.fit(iris.data)
  sse.append(km.inertia_)

plt.plot(list(range(1,8)),sse)
plt.xlabel('k')
plt.ylabel('sse')
plt.title('Error as a function of k')
plt.plot()